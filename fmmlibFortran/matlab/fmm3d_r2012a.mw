@function Readme()
%README
%
% Copyright (C) 2009-2012: Leslie Greengard and Zydrunas Gimbutas
% Contact: greengard@cims.nyu.edu
% 
% This program is free software; you can redistribute it and/or modify 
% it under the terms of the GNU General Public License as published by 
% the Free Software Foundation; either version 2 of the License, or 
% (at your option) any later version.  This program is distributed in 
% the hope that it will be useful, but WITHOUT ANY WARRANTY; without 
% even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
% PARTICULAR PURPOSE.  See the GNU General Public License for more 
% details. You should have received a copy of the GNU General Public 
% License along with this program; 
% if not, see <http://www.gnu.org/licenses/>.
%


@function [U]=hfmm3dtria(iprec,zk,nsource,triaflat,trianorm,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%HFMM3DTRIA Helmholtz triangle FMM in R^3.
%
% [U]=HFMM3DTRIA(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=HFMM3DTRIA(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=HFMM3DTRIA(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=HFMM3DTRIA(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Helmholtz potential and field due
% to a collection of flat triangles with constant single and/or
% double layer densities. We use (exp(ikr)/r) for the Green's function,
% without the (1/4 pi) scaling.  Self-interactions are included.
%
% It is capable of evaluating the layer potentials either on or 
% off the surface (or both).            
%
%
% Input parameters:
% 
% iprec - FMM precision flag
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% zk - complex Helmholtz parameter
% nsource - number of triangles
% triaflat - real (3,3,nsource): array of triangle vertex coordinates
% trianorm - real (3,nsource): triangle normals
% source - real (3,nsource): triangle centroids
% ifcharge - single layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz SLP contribution
%         2 => include Helmholtz SLP contribution and subtract Laplace SLP
% 
% charge - complex (nsource): piecewise constant SLP (charge) strength 
% ifdipole - double layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz DLP contribution
%         2 => include Helmholtz DLP contribution and subtract Laplace DLP
% 
% dipole - complex (nsource): piecewise constant DLP (dipole) strength 
% dipvec - real (3,nsource): piecewise constant dipole orientation vectors
%
%        In the present version, dipvec MUST BE SET EQUAL
%        to the triangle normal. It is here as an additional
%        parameter for future use, where an arbitrarily 
%        oriented dipole vector is permitted.
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%         1 => compute the potential, otherwise no
% iffldtarg - target field computation flag, 
%         1 => compute the field, otherwise no
%
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at triangle centroids
% U.fld - complex (3,nsource) - field (i.e. -gradient) at triangle centroids
% U.pottarg - complex (ntarget) - potential at targets
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at targets
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%             ier=4     =>  cannot allocate tree workspace
%             ier=8     =>  cannot allocate bulk FMM  workspace
%             ier=16    =>  cannot allocate mpole expansion workspace in FMM
%

if( nargin == 11 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 13 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 15 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

if( ntarget == 0 ) 
# FORTRAN hfmm3dtriaself(inout int[1] ier, int[1] iprec, dcomplex[1] zk, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld);
else
# FORTRAN hfmm3dtriatarg(inout int[1] ier, int[1] iprec, dcomplex[1] zk, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);
end

if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


@function [U]=h3dtriadirect(iprec,zk,nsource,triaflat,trianorm,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%H3DTRIADIRECT Helmholtz interactions in R^3, direct evaluation.
%
% [U]=H3DTRIADIRECT(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=H3DTRIADIRECT(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=H3DTRIADIRECT(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=H3DTRIADIRECT(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Helmholtz potential and field due
% to a collection of flat triangles with constant single and/or
% double layer densities. We use (exp(ikr)/r) for the Green's function,
% without the (1/4 pi) scaling.  Self-interactions are included.
%
% It is capable of evaluating the layer potentials either on or 
% off the surface (or both).            
%
%
% Input parameters:
% 
% iprec - precision flag, as used in FMM
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% zk - complex Helmholtz parameter
% nsource - number of triangles
% triaflat - real (3,3,nsource): array of triangle vertex coordinates
% trianorm - real (3,nsource): triangle normals
% source - real (3,nsource): triangle centroids
% ifcharge - single layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz SLP contribution
%         2 => include Helmholtz SLP contribution and subtract Laplace SLP
% 
% charge - complex (nsource): piecewise constant SLP (charge) strength 
% ifdipole - double layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz DLP contribution
%         2 => include Helmholtz DLP contribution and subtract Laplace DLP
% 
% dipole - complex (nsource): piecewise constant DLP (dipole) strength 
% dipvec - real (3,nsource): piecewise constant dipole orientation vectors
%
%        In the present version, dipvec MUST BE SET EQUAL
%        to the triangle normal. It is here as an additional
%        parameter for future use, where an arbitrarily 
%        oriented dipole vector is permitted.
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%         1 => compute the potential, otherwise no
% iffldtarg - target field computation flag, 
%         1 => compute the field, otherwise no
%
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at triangle centroids
% U.fld - complex (3,nsource) - field (i.e. -gradient) at triangle centroids
% U.pottarg - complex (ntarget) - potential at targets
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at targets
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%

if( nargin == 11 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 13 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 15 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

%
% The following assumes resonably regular triangulation.
%
%       nqtri: integer: number of quadrature nodes.
%          Suggested values for nqtri
%          iprec:  FMM precision flag
%                 -2 => tolerance =.5d0
%                 -1 => tolerance =.5d-1
%                  0 => tolerance =.5d-2
%                  1 => tolerance =.5d-3
%                  2 => tolerance =.5d-6
%                  3 => tolerance =.5d-9
%                  4 => tolerance =.5d-12
%                  5 => tolerance =.5d-15
%          if( iprec .eq. -2 ) nqtri=1
%          if( iprec .eq. -1 ) nqtri=2
%          if( iprec .eq.  0 ) nqtri=3
%          if( iprec .ge.  1 ) nqtri=6
%
nqtri=1;
if( iprec == -2), nqtri = 1; end;
if( iprec == -1), nqtri = 2; end;
if( iprec ==  0), nqtri = 3; end;
if( iprec >=  1), nqtri = 6; end;


# FORTRAN h3dtriadirect(int[1] nqtri, dcomplex[1] zk, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);


if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


@function [U]=lfmm3dtria(iprec,nsource,triaflat,trianorm,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%LFMM3DTRIA Laplace triangle FMM in R^3.
%
% [U]=LFMM3DTRIA(IPREC,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=LFMM3DTRIA(IPREC,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=LFMM3DTRIA(IPREC,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=LFMM3DTRIA(IPREC,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Laplace potential and field due
% to a collection of flat triangles with constant single and/or
% double layer densities. We use (1/r) for the Green's function,
% without the (1/4 pi) scaling.  Self-interactions are included.
%
% It is capable of evaluating the layer potentials either on or 
% off the surface (or both).            
%
%
% Input parameters:
% 
% iprec - FMM precision flag
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% nsource - number of triangles
% triaflat - real (3,3,nsource): array of triangle vertex coordinates
% trianorm - real (3,nsource): triangle normals
% source - real (3,nsource): triangle centroids
% ifcharge - single layer computation flag
%
%         0 => do not compute
%         1 => include Laplace SLP contribution
% 
% charge - complex (nsource): piecewise constant SLP (charge) strength 
% ifdipole - double layer computation flag
%
%         0 => do not compute
%         1 => include Laplace DLP contribution
% 
% dipole - complex (nsource): piecewise constant DLP (dipole) strength 
% dipvec - real (3,nsource): piecewise constant dipole orientation vectors
%
%        In the present version, dipvec MUST BE SET EQUAL
%        to the triangle normal. It is here as an additional
%        parameter for future use, where an arbitrarily 
%        oriented dipole vector is permitted.
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%         1 => compute the potential, otherwise no
% iffldtarg - target field computation flag, 
%         1 => compute the field, otherwise no
%
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at triangle centroids
% U.fld - complex (3,nsource) - field (i.e. -gradient) at triangle centroids
% U.pottarg - complex (ntarget) - potential at targets
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at targets
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%             ier=4     =>  cannot allocate tree workspace
%             ier=8     =>  cannot allocate bulk FMM  workspace
%             ier=16    =>  cannot allocate mpole expansion workspace in FMM
%

if( nargin == 10 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 12 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 14 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

if( ntarget == 0 ) 
# FORTRAN lfmm3dtriaself(inout int[1] ier, int[1] iprec, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld);
else
# FORTRAN lfmm3dtriatarg(inout int[1] ier, int[1] iprec, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);
end

if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


@function [U]=l3dtriadirect(nsource,triaflat,trianorm,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%LFMM3DTRIADIRECT Laplace interactions in R^3, direct evaluation.
%
% [U]=L3DTRIADIRECT(NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=L3DTRIADIRECT(NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=L3DTRIADIRECT(NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=L3DTRIADIRECT(NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Laplace potential and field due
% to a collection of flat triangles with constant single and/or
% double layer densities. We use (1/r) for the Green's function,
% without the (1/4 pi) scaling.  Self-interactions are included.
%
% It is capable of evaluating the layer potentials either on or 
% off the surface (or both).            
%
%
% Input parameters:
% 
% nsource - number of triangles
% triaflat - real (3,3,nsource): array of triangle vertex coordinates
% trianorm - real (3,nsource): triangle normals
% source - real (3,nsource): triangle centroids
% ifcharge - single layer computation flag
%
%         0 => do not compute
%         1 => include Laplace SLP contribution
% 
% charge - complex (nsource): piecewise constant SLP (charge) strength 
% ifdipole - double layer computation flag
%
%         0 => do not compute
%         1 => include Laplace DLP contribution
% 
% dipole - complex (nsource): piecewise constant DLP (dipole) strength 
% dipvec - real (3,nsource): piecewise constant dipole orientation vectors
%
%        In the present version, dipvec MUST BE SET EQUAL
%        to the triangle normal. It is here as an additional
%        parameter for future use, where an arbitrarily 
%        oriented dipole vector is permitted.
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%         1 => compute the potential, otherwise no
% iffldtarg - target field computation flag, 
%         1 => compute the field, otherwise no
%
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at triangle centroids
% U.fld - complex (3,nsource) - field (i.e. -gradient) at triangle centroids
% U.pottarg - complex (ntarget) - potential at targets
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at targets
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%

if( nargin == 9 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 11 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 13 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

# FORTRAN l3dtriadirect(int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);


if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;



@function [U]=hfmm3dpart(iprec,zk,nsource,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%HFMM3DPART Helmholtz particle target FMM in R^3.
%
% Helmholtz FMM in R^3: evaluate all pairwise particle
% interactions (ignoring self-interactions) and interactions with targets.
%
% [U]=HFMM3DPART(IPREC,ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=HFMM3DPART(IPREC,ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=HFMM3DPART(IPREC,ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=HFMM3DPART(IPREC,ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Helmholtz potential and field due
% to a collection of charges and dipoles. We use (exp(ikr)/r) for the 
% Green's function, without the (1/4 pi) scaling. 
% Self-interactions are not-included.
%
% Input parameters:
% 
% iprec - FMM precision flag
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% zk - complex Helmholtz parameter
% nsource - number of sources
% source - real (3,nsource): source locations
% ifcharge - charge computation flag
%
%         0 => do not compute
%         1 => include charge contribution
% 
% charge - complex (nsource): charge strengths 
% ifdipole - dipole computation flag
%
%         0 => do not compute
%         1 => include dipole contributions
% 
% dipole - complex (nsource): dipole strengths
% dipvec - real (3,source): dipole orientation vectors
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%      1 => compute the target potential, otherwise no
% iffldtarg - target field computation flag, 
%      1 => compute the target field, otherwise no
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at source locations
% U.fld - complex (3,nsource) - field (i.e. -gradient) at source locations
% U.pottarg - complex (ntarget) - potential at target locations
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at target locations
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%             ier=4     =>  cannot allocate tree workspace
%             ier=8     =>  cannot allocate bulk FMM  workspace
%             ier=16    =>  cannot allocate mpole expansion workspace in FMM
%

if( nargin == 9 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 11 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 13 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

if( ntarget == 0 ) 
# FORTRAN hfmm3dpartself(inout int[1] ier, int[1] iprec, dcomplex[1] zk, int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld);
else
# FORTRAN hfmm3dparttarg(inout int[1] ier, int[1] iprec, dcomplex[1] zk, int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);
end

if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


@function [U]=h3dpartdirect(zk,nsource,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%HFMM3DPARTDIRECT Helmholtz interactions in R^3, direct evaluation.
%
% Helmholtz FMM in R^3: evaluate all pairwise particle
% interactions (ignoring self-interactions) and interactions with targets.
%
% [U]=H3DPARTDIRECT(ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=H3DPARTDIRECT(ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=H3DPARTDIRECT(ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=H3DPARTDIRECT(ZK,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Helmholtz potential and field due
% to a collection of charges and dipoles. We use (exp(ikr)/r) for the 
% Green's function, without the (1/4 pi) scaling. 
% Self-interactions are not-included.
%
% Input parameters:
% 
% zk - complex Helmholtz parameter
% nsource - number of sources
% source - real (3,nsource): source locations
% ifcharge - charge computation flag
%
%         0 => do not compute
%         1 => include charge contribution
% 
% charge - complex (nsource): charge strengths 
% ifdipole - dipole computation flag
%
%         0 => do not compute
%         1 => include dipole contributions
% 
% dipole - complex (nsource): dipole strengths
% dipvec - real (3,source): dipole orientation vectors
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%      1 => compute the target potential, otherwise no
% iffldtarg - target field computation flag, 
%      1 => compute the target field, otherwise no
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at source locations
% U.fld - complex (3,nsource) - field (i.e. -gradient) at source locations
% U.pottarg - complex (ntarget) - potential at target locations
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at target locations
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%

if( nargin == 8 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 10 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 12 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

# FORTRAN h3dpartdirect(dcomplex[1] zk, int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);


if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


@function [U]=lfmm3dpart(iprec,nsource,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%LFMM3DPART Laplace particle target FMM in R^3.
%
% Laplace FMM in R^3: evaluate all pairwise particle
% interactions (ignoring self-interactions) and interactions with targets.
%
% [U]=LFMM3DPART(IPREC,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=LFMM3DPART(IPREC,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=LFMM3DPART(IPREC,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=LFMM3DPART(IPREC,NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Laplace potential and field due
% to a collection of charges and dipoles. We use (1/r) for the 
% Green's function, without the (1/4 pi) scaling. 
% Self-interactions are not-included.
%
% Input parameters:
% 
% iprec - FMM precision flag
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% nsource - number of sources
% source - real (3,nsource): source locations
% ifcharge - charge computation flag
%
%         0 => do not compute
%         1 => include charge contribution
% 
% charge - complex (nsource): charge strengths 
% ifdipole - dipole computation flag
%
%         0 => do not compute
%         1 => include dipole contributions
% 
% dipole - complex (nsource): dipole strengths
% dipvec - real (3,source): dipole orientation vectors
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%      1 => compute the target potential, otherwise no
% iffldtarg - target field computation flag, 
%      1 => compute the target field, otherwise no
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at source locations
% U.fld - complex (3,nsource) - field (i.e. -gradient) at source locations
% U.pottarg - complex (ntarget) - potential at target locations
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at target locations
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%             ier=4     =>  cannot allocate tree workspace
%             ier=8     =>  cannot allocate bulk FMM  workspace
%             ier=16    =>  cannot allocate mpole expansion workspace in FMM
%

if( nargin == 8 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 10 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 12 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

if( ntarget == 0 ) 
# FORTRAN lfmm3dpartself(inout int[1] ier, int[1] iprec, int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld);
else
# FORTRAN lfmm3dparttarg(inout int[1] ier, int[1] iprec, int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);
end

if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;



@function [U]=l3dpartdirect(nsource,source,ifcharge,charge,ifdipole,dipstr,dipvec,ifpot,iffld,ntarget,target,ifpottarg,iffldtarg)
%LFMM3DPARTDIRECT Laplace interactions in R^3, direct evaluation.
%
% Laplace FMM in R^3: evaluate all pairwise particle
% interactions (ignoring self-interactions) and interactions with targets.
%
% [U]=L3DPARTDIRECT(NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC);
%
% [U]=L3DPARTDIRECT(NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD);
%
% [U]=L3DPARTDIRECT(NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET);
%
% [U]=L3DPARTDIRECT(NSOURCE,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,IFPOT,IFFLD,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Laplace potential and field due
% to a collection of charges and dipoles. We use (1/r) for the 
% Green's function, without the (1/4 pi) scaling. 
% Self-interactions are not-included.
%
% Input parameters:
% 
% nsource - number of sources
% source - real (3,nsource): source locations
% ifcharge - charge computation flag
%
%         0 => do not compute
%         1 => include charge contribution
% 
% charge - complex (nsource): charge strengths 
% ifdipole - dipole computation flag
%
%         0 => do not compute
%         1 => include dipole contributions
% 
% dipole - complex (nsource): dipole strengths
% dipvec - real (3,source): dipole orientation vectors
%
% ifpot - potential computation flag, 1 => compute the potential, otherwise no
% iffld - field computation flag, 1 => compute the field, otherwise no
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%      1 => compute the target potential, otherwise no
% iffldtarg - target field computation flag, 
%      1 => compute the target field, otherwise no
%
% Output parameters: 
%
% U.pot - complex (nsource) - potential at source locations
% U.fld - complex (3,nsource) - field (i.e. -gradient) at source locations
% U.pottarg - complex (ntarget) - potential at target locations
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at target locations
%
% U.ier - error return code
%
%             ier=0     =>  normal execution

if( nargin == 7 ) 
  ifpot = 1;
  iffld = 1;
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 9 ) 
  ntarget = 0;
  target = zeros(3,1);
  ifpottarg = 0;
  iffldtarg = 0;
end

if( nargin == 11 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

ifcharge = double(ifcharge); ifdipole = double(ifdipole);
ifpot = double(ifpot); iffld = double(iffld);
ifpottarg = double(ifpottarg); iffldtarg = double(iffldtarg);

pot=0;
fld=zeros(3,1);
pottarg=0;
fldtarg=zeros(3,1);

if( ifpot == 1 ), pot=zeros(1,nsource)+1i*zeros(1,nsource); end;
if( iffld == 1 ), fld=zeros(3,nsource)+1i*zeros(3,nsource); end;
if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

# FORTRAN l3dpartdirect(int[1] nsource, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ifpot, inout dcomplex[] pot, int[1] iffld, inout dcomplex[] fld, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);


if( ifpot == 1 ), U.pot=pot; end
if( iffld == 1 ), U.fld=fld; end
if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;



@function [U]=d3tstrcr(nsource,source,nbox,ntarget,target)
%D3TSTRCR Construct the logical structure for a fully adaptive FMM in R^3.
%
%  [U]=D3TSTRCR(NSOURCE,SOURCE,NBOX);
%
%  [U]=D3TSTRCR(NSOURCE,SOURCE,NBOX,NTARGET,TARGET);
%
%  This subroutine constructs the logical structure for the 
%  fully adaptive FMM in three dimensions and stores it in the
%  structure U.  It is capable of constructing the oct-tree on 
%  both sources and targets.
%
%  After that, the user can obtain the information about various boxes 
%  and lists in it by calling D3TGETB, D3TGETL.
%
%  Input parameters:
%  
%  nsource - number of sources
%  source - real (3,nsource) - source locations
%  nbox - maximum number of points in a box on the finest level
%  ntarget - number of targets
%  target - real (3,ntarget) - target locations
%
%  Output parameters:
%
%  U.nboxes - the number of boxes created
%  U.isource - the integer array, addressing the particles in boxes
%       Explanation: for a box ibox, the particles living in it are:
%         (source(1,j),source(2,j),source(3,j)),
%         (source(1,j+1),source(2,j+1),source(3,j+1)),
%         (source(1,j+2),source(2,j+2),source(3,j+3)), ... 
%         (source(1,j+nj-1),source(2,j+nj-1),source(3,j+nj-1)),
%         (source(1,j+nj),source(2,j+nj),source(3,j+nj)),
%         with j=boxes(14,ibox), and nj=boxes(15,ibox)
%  U.nlev - the maximum level number on which any boxes have been created
%  U.laddr - an integer array dimensioned (2,nlev), describing the
%         numbers of boxes on various levels of sybdivision, so that
%         the first box on level (i-1) has sequence number laddr(1,i),
%         and there are laddr(2,i) boxes on level i-1
%  U.center - the center of the box on the level 0, 
%             containing the whole simulation
%  U.size - the side of the box on the level 0
%  U.lists -  the array containing all tables describing boxes, lists, etc. 
%         it is a link-list (for the most part), and can only be accessed
%         via the entries D3TGETB, D3TGETL.
%  U.itarget - the integer array, addressing the target particles in boxes
%       Explanation: for a box ibox, the targets living in it are:
%         (target(1,j),target(2,j),target(3,j)),
%         (target(1,j+1),target(2,j+1),target(3,j+1)),
%         (target(1,j+2),target(2,j+2),target(3,j+3)), ... 
%         (target(1,j+nj-1),target(2,j+nj-1),target(3,j+nj-1)),
%         (target(1,j+nj),target(2,j+nj),target(3,j+nj)),
%         with j=boxes(16,ibox), and nj=boxes(17,ibox)
%  U.lused - the amount of workspace used for storing U.lists
%
%  U.lw - the amount of workspace used for creating U.lists
%  U.ier - error return code
%    ier=0  - successful execution.
%    ier=32 - the amount lw of space in array w is insufficient.
%    ier=16 - the subroutine attempted to construct more 
%        than 199 levels of subdivision; indicates bad trouble.
%    ier=64 - the amount lw of space in array w is severely insufficient.
%

if( nargin == 3 )
  ntarget = 0;
  target = zeros(3,1);
  itarget = zeros(1,1);
end

isource = zeros(1,nsource);
if( ntarget > 0 ) itarget = zeros(1,ntarget); end

nlev = 0;
nboxes = 0;
laddr = zeros(2,400);

center = zeros(3,1);
size = 0;

lw = 100*(nsource+ntarget)+10000;
for i=1:10

w = zeros(1,lw);
lused=0;

ier = 0;

# FORTRAN d3tstrcr(inout int[1] ier,double[] source,int[1] nsource,inout int[1] nbox,inout int[1] nboxes,inout int[] isource,inout int[] laddr,inout int[1] nlev,inout double[] center,inout double[] size,double[] target,int[1] ntarget,inout int[] itarget,inout double[] w,int[1] lw,inout int[1] lused);

if( ier > 0 ) 
% increase memory allocation
  lw = lw*1.5;
else
  break;
end

end

U.nbox = nbox;

U.nboxes = nboxes;
U.nlev = nlev;
U.laddr = laddr;
U.center = center;
U.size = size;

if( ier == 0 ), U.lists = w(1,1:lused); end

U.isource = isource;
if( ntarget > 0 ), U.itarget = itarget; end

U.lw = lw;
U.lused = lused;
U.ier=ier;


@function [U]=d3tstrcrem(nsource,source,nbox,ifempty,minlev,maxlev,ntarget,target)
%D3TSTRCREM See D3TSTRCR, include empty boxes, min and max level restriction.
%
%  [U]=D3TSTRCREM(NSOURCE,SOURCE,NBOX);
%
%  [U]=D3TSTRCREM(NSOURCE,SOURCE,NBOX,IFEMPTY,MINLEV,MAXLEV);
%
%  [U]=D3TSTRCREM(NSOURCE,SOURCE,NBOX,IFEMPTY,MINLEV,MAXLEV,NTARGET,TARGET);
%
%  This subroutine constructs the logical structure for the 
%  fully adaptive FMM in three dimensions and stores it in the
%  structure U.  It is capable of constructing the oct-tree on 
%  both sources and targets. 
%
%  After that, the user can obtain the information about various boxes 
%  and lists in it by calling D3TGETB, D3TGETL.
%
%  Input parameters:
%  
%  nsource - number of sources
%  source - real (3,nsource) - source locations
%  nbox - maximum number of points in a box on the finest level
%  ntarget - number of targets
%  target - real (3,ntarget) - target locations
%
%  ifempty - ifempty=0 - remove empty boxes, ifempty=1 - keep empty boxes 
%  minlevel - minimum level of refinement
%  maxlevel - minimum level of refinement
%
%  Output parameters:
%
%  U.nboxes - the number of boxes created
%  U.isource - the integer array, addressing the particles in boxes
%       Explanation: for a box ibox, the particles living in it are:
%         (source(1,j),source(2,j),source(3,j)),
%         (source(1,j+1),source(2,j+1),source(3,j+1)),
%         (source(1,j+2),source(2,j+2),source(3,j+3)), ... 
%         (source(1,j+nj-1),source(2,j+nj-1),source(3,j+nj-1)),
%         (source(1,j+nj),source(2,j+nj),source(3,j+nj)),
%         with j=boxes(14,ibox), and nj=boxes(15,ibox)
%  U.nlev - the maximum level number on which any boxes have been created
%  U.laddr - an integer array dimensioned (2,nlev), describing the
%         numbers of boxes on various levels of sybdivision, so that
%         the first box on level (i-1) has sequence number laddr(1,i),
%         and there are laddr(2,i) boxes on level i-1
%  U.center - the center of the box on the level 0, 
%             containing the whole simulation
%  U.size - the side of the box on the level 0
%  U.lists -  the array containing all tables describing boxes, lists, etc. 
%         it is a link-list (for the most part), and can only be accessed
%         via the entries D3TGETB, D3TGETL.
%  U.itarget - the integer array, addressing the target particles in boxes
%       Explanation: for a box ibox, the targets living in it are:
%         (target(1,j),target(2,j),target(3,j)),
%         (target(1,j+1),target(2,j+1),target(3,j+1)),
%         (target(1,j+2),target(2,j+2),target(3,j+3)), ... 
%         (target(1,j+nj-1),target(2,j+nj-1),target(3,j+nj-1)),
%         (target(1,j+nj),target(2,j+nj),target(3,j+nj)),
%         with j=boxes(16,ibox), and nj=boxes(17,ibox)
%  U.lused - the amount of workspace used for storing U.lists
%
%  U.lw - the amount of workspace used for creating U.lists
%  U.ier - error return code
%    ier=0  - successful execution.
%    ier=32 - the amount lw of space in array w is insufficient.
%    ier=16 - the subroutine attempted to construct more 
%        than 199 levels of subdivision; indicates bad trouble.
%    ier=64 - the amount lw of space in array w is severely insufficient.
%

if( nargin == 3 )
  ifempty = 0;
  minlev = 0;
  maxlev = 200;
  ntarget = 0;
  target = zeros(3,1);
  itarget = zeros(1,1);
end

if( nargin == 6 )
  ntarget = 0;
  target = zeros(3,1);
  itarget = zeros(1,1);
end


isource = zeros(1,nsource);
if( ntarget > 0 ), itarget = zeros(1,ntarget); end

nlev = 0;
nboxes = 0;
laddr = zeros(2,400);

center = zeros(3,1);
size = 0;

lw = 100*(nsource+ntarget)+10000;
for i=1:10

w = zeros(1,lw);
lused=0;

ier = 0;

# FORTRAN d3tstrcrem(inout int[1] ier,double[] source,int[1] nsource,inout int[1] nbox,inout int[1] nboxes,inout int[] isource,inout int[] laddr,inout int[1] nlev,inout double[] center,inout double[] size,double[] target,int[1] ntarget,inout int[] itarget,inout double[] w,int[1] lw,inout int[1] lused, int[1] ifempty, int[1] minvel, int[1] maxlev);

if( ier > 0 ) 
% increase memory allocation
  lw = lw*1.5;
else
  break;
end

end


U.nbox = nbox;
U.ifempty = ifempty;
U.minlev = minlev;
U.maxlev = maxlev;

U.nboxes = nboxes;
U.nlev = nlev;
U.laddr = laddr;
U.center = center;
U.size = size;

if( ier == 0 ), U.lists = w(1,1:lused); end

U.isource = isource;
if( ntarget > 0 ), U.itarget = itarget; end

U.lw = lw;
U.lused = lused;
U.ier=ier;



@function [ier,box,center,corners]=d3tgetb(ibox,lists)
%D3TGETB Retrieve box information.
%
% [IER,BOX,CENTER,CORNERS]=D3TGETB(IBOX,LISTS);
%
% Input parameters:
%
% ibox - the box number for which the information is desired
% lists - storage area U.lists as created be D3TSTRCR or D3TSTRCREM
%
% Output parameters:
%
% ier - error return code
%    ier=0 - successful execution
%    ier=4 - ibox is either greater than the number of boxes 
%            in the structure or less than 1.
%
% box - an integer array dimensioned box(20). its elements describe 
%        the box number ibox, as follows:
%
%       1. level - the level of subdivision on which this box 
%             was constructed; 
%       2, 3, 4  - the coordinates of this box among  all
%             boxes on this level
%       5 - the daddy of this box, identified by it address
%             in array boxes
%       6,7,8,9,10,11,12,13 - the  list of children of this box 
%             (eight of them, and the child is identified by its address
%             in the array boxes; if a box has only one child, only the
%             first of the four child entries is non-zero, etc.)
%       14 - the location in the array iz of the particles 
%             living in this box
%       15 - the number of particles living in this box
%       16 - the location in the array iztarg of the targets
%             living in this box
%       17 - the number of targets living in this box
%       18 - source box type: 0 - empty, 1 - leaf node, 2 - sub-divided
%       19 - target box type: 0 - empty, 1 - leaf node, 2 - sub-divided
%       20 - reserved for future use
%
% center - real (3) - the center of the box number ibox 
% corners - real (3,8) - the corners of the box number ibox 
%

ier = 0;
center = zeros(3,1);
corners = zeros(3,8);
box = zeros(1,20);

# FORTRAN d3tgetb(inout int[1] ier,int[1] ibox,inout int[] box,inout double[] center,inout double[] corners,double[] lists);



@function [ier,list,nlist]=d3tgetl(ibox,itype,lists)
%D3TGETL Retrieve list information.
%
% [IER,LIST,NLIST]=D3TGETL(IBOX,ITYPE,LISTS);
%
% Input parameters:
%
% ibox - the box number for which the information is desired
% itype - the type of the desired list for the box ibox
% lists - storage area U.lists as created be D3TSTRCR or D3TSTRCREM
%
% Output parameters:
%
% ier - the error return code.
%    ier=0 - successful execution
%    ier=4 - the list  itype  for the box  ibox  is empty
% list - the list  itype  for the box  ibox 
% nlist - the number of elements in array  list
%

ier = 0;
list = zeros(1,10000);
nlist = 0;

# FORTRAN d3tgetl(inout int[1] ier,int[1] ibox,int[1] itype,inout int[] list,inout int[] nlist,double[] lists);

if( ier == 0 ), list = list(1,1:nlist); end
if( ier  > 0 ), list = list(1,1); end




@function fmm3dprini(unit1,unit2)
%FMM3DPRINI Initialize simple printing routines.
%
% Calling FMM3DPRINI(6,13) causes printing to screen and file fort.13.     
%

if (nargin == 1 )
unit2=0;
end

# FORTRAN prini(int[1] unit1, int[1] unit2);


@function [U]=hfmm3dtriampf(iprec,zk,nsource,triaflat,trianorm,source,ifcharge,charge,ifdipole,dipstr,dipvec,ntarget,target,ifpottarg,iffldtarg)
%HFMM3DTRIAMPF Helmholtz triangle FMM in R^3, target evaluation only.
%
% [U]=HFMM3DTRIAMPF(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,...
%         NTARGET,TARGET);
%
% [U]=HFMM3DTRIAMPF(IPREC,ZK,NSOURCE,TRIAFLAT,TRIANORM,SOURCE,...
%         IFCHARGE,CHARGE,IFDIPOLE,DIPSTR,DIPVEC,...
%         NTARGET,TARGET,IFPOTTARG,IFFLDTARG);
%
%
% This subroutine evaluates the Helmholtz potential and field due
% to a collection of flat triangles with constant single and/or
% double layer densities. We use (exp(ikr)/r) for the Green's function,
% without the (1/4 pi) scaling. 
%
% It is capable of evaluating the layer potentials off the surface only.
%
%
% Input parameters:
% 
% iprec - FMM precision flag
%
%             -2 => tolerance =.5d0   =>  
%             -1 => tolerance =.5d-1  =>  1 digit 
%              0 => tolerance =.5d-2  =>  2 digits
%              1 => tolerance =.5d-3  =>  3 digits
%              2 => tolerance =.5d-6  =>  6 digits
%              3 => tolerance =.5d-9  =>  9 digits
%              4 => tolerance =.5d-12 => 12 digits
%              5 => tolerance =.5d-15 => 15 digits
%
% zk - complex Helmholtz parameter
% nsource - number of triangles
% triaflat - real (3,3,nsource): array of triangle vertex coordinates
% trianorm - real (3,nsource): triangle normals
% source - real (3,nsource): triangle centroids
% ifcharge - single layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz SLP contribution
%         2 => include Helmholtz SLP contribution and subtract Laplace SLP
% 
% charge - complex (nsource): piecewise constant SLP (charge) strength 
% ifdipole - double layer computation flag
%
%         0 => do not compute
%         1 => include Helmholtz DLP contribution
%         2 => include Helmholtz DLP contribution and subtract Laplace DLP
% 
% dipole - complex (nsource): piecewise constant DLP (dipole) strength 
% dipvec - real (3,nsource): piecewise constant dipole orientation vectors
%
%        In the present version, dipvec MUST BE SET EQUAL
%        to the triangle normal. It is here as an additional
%        parameter for future use, where an arbitrarily 
%        oriented dipole vector is permitted.
%
% ntarget - number of targets
% target - real (3,ntarget): target locations
%
% ifpottarg - target potential computation flag, 
%         1 => compute the potential, otherwise no
% iffldtarg - target field computation flag, 
%         1 => compute the field, otherwise no
%
%
% Output parameters: 
%
% U.pottarg - complex (ntarget) - potential at targets
% U.fldtarg - complex (3,ntarget) - field (i.e. -gradient) at targets
%
% U.ier - error return code
%
%             ier=0     =>  normal execution
%             ier=4     =>  cannot allocate tree workspace
%             ier=8     =>  cannot allocate bulk FMM  workspace
%             ier=16    =>  cannot allocate mpole expansion workspace in FMM
%

if( nargin == 13 ) 
  ifpottarg = 1;
  iffldtarg = 1;
end

pottarg=0;
fldtarg=zeros(3,1);

if( ifpottarg == 1 ), pottarg=zeros(1,ntarget)+1i*zeros(1,ntarget); end;
if( iffldtarg == 1 ), fldtarg=zeros(3,ntarget)+1i*zeros(3,ntarget); end;

ier=0;

# FORTRAN hfmm3dtriampftarg(inout int[1] ier, int[1] iprec, dcomplex[1] zk, int[1] nsource, double[] triaflat, double[3,nsource] trianorm, double[3,nsource] source, int[1] ifcharge, dcomplex[] charge, int[1] ifdipole, dcomplex[] dipstr, double [3,nsource] dipvec, int[1] ntarget, double[] target, int[1] ifpottarg, inout dcomplex[] pottarg, int[1] iffldtarg, inout dcomplex[] fldtarg);


if( ifpottarg == 1 ), U.pottarg=pottarg; end
if( iffldtarg == 1 ), U.fldtarg=fldtarg; end
U.ier=ier;


